<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>brownbear.fetch API documentation</title>
<meta name="description" content="Fetch performance data for investment options." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>brownbear.fetch</code></h1>
</header>
<section id="section-intro">
<p>Fetch performance data for investment options.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Fetch performance data for investment options.
&#34;&#34;&#34;

import pandas as pd

import brownbear as bb
from brownbear.portfolio import (
    PORT,
    sharpe_ratio
)
from brownbear.utility import (
    csv_to_df
)


########################################################################
# FETCH

def _correlation_table_to_dict():
    &#34;&#34;&#34;
    Return a dictionary of the correlation_table.
    &#34;&#34;&#34;
    df = PORT.correlation_table.set_index([&#39;Asset Class A&#39;, &#39;Asset Class B&#39;])
    # Make any na values perfectly correlated=1; convert to float.
    df[&#39;Correlation&#39;] = df[&#39;Correlation&#39;].fillna(1)
    df[&#39;Correlation&#39;] = df[&#39;Correlation&#39;].astype(float)
    d = df[&#39;Correlation&#39;].to_dict()
    return d


def _add_sharpe_ratio_column(inv_opts, risk_free_rate):
    &#34;&#34;&#34;
    Add Sharpe Ratio column to the inv_opts dataframe.
    &#34;&#34;&#34;
    def _sharpe(row, risk_free_rate):
        annual_ret = row[&#39;Annual Returns&#39;]
        std_dev = row[&#39;Std Dev&#39;]
        return sharpe_ratio(annual_ret, std_dev, risk_free_rate)

    inv_opts[&#39;Sharpe Ratio&#39;] = inv_opts.apply(_sharpe, risk_free_rate=risk_free_rate, axis=1)
    return inv_opts


def fetch(investment_universe, risk_free_rate=0, annual_returns=&#39;Annual Returns&#39;,
          vola=&#39;Std Dev&#39;, ds_vola=&#39;Std Dev&#39;, clean=True):
    &#34;&#34;&#34;
    Fetch Investment Universe and asset classes

    investment-options.csv format:
        &#34;Investment Option&#34;, &#34;Description&#34;(optimal), &#34;Asset Class&#34;,
        &#34;Annual Returns&#34;, &#34;Std Dev&#34;

    asset-classes.csv format:
        &#34;Asset Class A&#34;, &#34;Asset Class B&#34;,&#34;Correlation&#34;
        &#34;Description&#34; field is optional.  It is not referenced in code.
        &#34;Annual Returns&#34; column(s) can named anything.
            Recommend &#34;1 Yr&#34;, &#34;3 Yr&#34;, &#34;5 Yr&#34;, or &#34;10 Yr&#34;.  Then
            annual_returns parameter can select the column to use.

    Parameters
    ----------
    investment_universe : list of str
        List of investment galaxies.  These are the dirs within
        universe/, for example [&#39;dow30-galaxy&#39;, &#39;alabama-galaxy&#39;].
    risk_free_rate : float, optional
        Risk free rate (default is 0).
    annual_returns : str, optional
        Specifies which column to use for annualized returns
        (default is &#39;Annual Returns&#39;).
    vola : str, optional
        Specifies which column to use for volatility
        (default is &#39;Std Dev&#39;).
    ds_vola : str, optional
        Specifies which column to use for downside volatility
        (default is &#39;Std Dev&#39;).
    clean : bool, optional
        True to remove rows that have a &#39;nan&#39; as a column value
        (default is True).

    Returns
    -------
    inv_opts : pd.DataFrame
        Dataframe of investment options with columns for asset class,
        description, and performace metrics.
    &#34;&#34;&#34;
    # If caller specified a single filename, put it in a list.
    if not isinstance(investment_universe, list):
        investment_universe = [investment_universe]

    # Create the investment options csv file list, then read into
    # a dataframe.  There are 2 places to look for
    # investment-options.csv files: under universe/ and portfolios/.
    filepaths = []
    for galaxy in investment_universe:
        for subdir in [&#39;universe&#39;, &#39;portfolios&#39;]:
            filepath = bb.ROOT / subdir / galaxy / &#39;investment-options.csv&#39;
            if filepath.is_file():
                filepaths.append(filepath)

    inv_opts = csv_to_df(filepaths)

    # Drop duplicate Investment Option&#39;s, keep the first,
    # then reset index.
    inv_opts.drop_duplicates(subset=[&#39;Investment Option&#39;], keep=&#39;first&#39;, inplace=True)
    inv_opts.reset_index(drop=True, inplace=True)

    # Allows the use of different annualized returns,
    # e.g. 1, 3, or 5 year annaulized returns.
    if annual_returns != &#39;Annual Returns&#39;:
        inv_opts[&#39;Annual Returns&#39;] = inv_opts[annual_returns]

    # Add Sharpe Ratio column.
    inv_opts = _add_sharpe_ratio_column(inv_opts, risk_free_rate)

    # Asset class table.
    PORT.asset_class_table = csv_to_df(
        [bb.ROOT / &#39;universe&#39; / &#39;asset-class-galaxy&#39; / &#39;investment-options.csv&#39;])

    # Add Annual Returns column to asset class table.
    if annual_returns in PORT.asset_class_table.columns:
        PORT.asset_class_table[&#39;Annual Returns&#39;] = PORT.asset_class_table[annual_returns]
    else:
        PORT.asset_class_table[&#39;Annual Returns&#39;] = PORT.asset_class_table[&#39;5 Yr&#39;]

    # Add Sharpe Ratio column to asset class table.
    PORT.asset_class_table = _add_sharpe_ratio_column(PORT.asset_class_table, risk_free_rate)

    # Correlation table.
    PORT.correlation_table = csv_to_df(
        [bb.ROOT / &#39;universe&#39; / &#39;asset-class-galaxy&#39; / &#39;asset-classes.csv&#39;])

    # Convert correlation table to dict for easier faster processing.
    PORT.correlation_table = _correlation_table_to_dict()

    # Set other module variables.
    PORT.investment_universe = investment_universe.copy()
    PORT.risk_free_rate = risk_free_rate
    PORT.vola_column = vola
    PORT.ds_vola_column = ds_vola

    if clean:
        # Remove any rows that have nan for column values.
        inv_opts = inv_opts.dropna()
        inv_opts.reset_index(drop=True, inplace=True)

    return inv_opts


########################################################################
# FUNDAMENTALS

def add_fundamental_columns(inv_opts, clean=True):
    &#34;&#34;&#34;
    Add fundamental data columns to inv_opts dataframe.

    Columns added:
      &#39;Previous Close&#39;,
      &#39;Trailing PE&#39;,
      &#39;Dividend Yield&#39;,
      &#39;Market Cap&#39;

    Parameters
    ----------
    inv_opts : pd.DataFrame
        Dataframe of investment options with columns for asset class,
        description, and performace metrics.
    clean : bool, optional
        True to remove rows that have a &#39;nan&#39; as a column value
        (default is True).

    Returns
    -------
    inv_opts : pd.DataFrame
        Dataframe of investment options with fundamental data columns.
    &#34;&#34;&#34;
    filepath = bb.ROOT / &#39;tools&#39; / &#39;symbol-cache&#39; / &#39;fundamentals.csv&#39;
    df = pd.read_csv(filepath)
    df.rename(columns={
        &#39;symbol&#39;: &#39;Investment Option&#39;,
        &#39;previousClose&#39;: &#39;Previous Close&#39;,
        &#39;trailingPE&#39;: &#39;Trailing PE&#39;,
        &#39;dividendYield&#39;: &#39;Dividend Yield&#39;,
        &#39;marketCap&#39;: &#39;Market Cap&#39;
        }, inplace=True)
    inv_opts = inv_opts.merge(df, how=&#39;left&#39;)
    if clean:
        # Remove any rows that have nan for column values.
        inv_opts = inv_opts.dropna()
        inv_opts.reset_index(drop=True, inplace=True)
    return inv_opts


########################################################################
# RANK

def rank(inv_opts, rank_by, group_by=None, num_per_group=None, ascending=False):
    &#34;&#34;&#34;
    Rank investment options.

    Parameters
    ----------
    inv_opts : pd.DataFrame
        Dataframe of investment options with columns for asset class,
        description, and performace metrics.
    rank_by : str
        The performance or fundamental metric used to sort the
        investment options.
    group_by : str, optional {None, &#39;Asset Class&#39;, &#39;Asset Subclass&#39;}
        How to group investment options (default is None, which imples
        no grouping)
    num_per_group : int, optional
        The number of investment options for each group
        (default is None, which imples 5 if group_by is specified, 
         otherwise 1000).
    ascending : bool, optional
        True to sort in ascending order (default is False, which imples
        sorting in descending order).

    Returns
    -------
    df : pd.DataFrame
        Dataframe of investment options with ranking.
    &#34;&#34;&#34;
    group_by_choices = (None, &#39;Asset Class&#39;, &#39;Asset Subclass&#39;)
    assert group_by in group_by_choices, &#34;Invalid group_by f&#39;{group_by}&#39;&#34;

    df = inv_opts.copy()

    # Temporarily add __asset_class__ and  __asset_subclass__ for
    # convenience; drop it later.S
    df[&#39;__asset_subclass__&#39;] = df[&#39;Asset Class&#39;]

    def _add_asset_class(row):
        # Extract the class_name from &#39;__asset_subclass__&#39; column.
        class_name = row[&#39;__asset_subclass__&#39;]
        class_name = class_name.split(&#39;:&#39;)[0]
        return class_name

    # Add &#39;__asset_class__&#39; column.
    df[&#39;__asset_class__&#39;] = df.apply(_add_asset_class, axis=1)

    # Sort.
    if group_by is None:
        if num_per_group is None:
            num_per_group = 10000
        df = df.sort_values(rank_by, ascending=ascending) \
                            .head(num_per_group)
    elif group_by == &#39;Asset Class&#39;:
        if num_per_group is None:
            num_per_group = 5
        df = df.sort_values([&#39;__asset_class__&#39;, rank_by], ascending=ascending) \
                            .groupby(&#39;__asset_class__&#39;).head(num_per_group)
    elif group_by == &#39;Asset Subclass&#39;:
        if num_per_group is None:
            num_per_group = 5
        df = df.sort_values([&#39;__asset_subclass__&#39;, rank_by], ascending=ascending) \
                            .groupby(&#39;__asset_subclass__&#39;).head(num_per_group)
    else:
        raise Exception(f&#34;Error: Invalid value for groupby: &#39;{group_by}&#39;&#34;)

    # Drop temporary column.
    df.drop(columns=[&#39;__asset_class__&#39;, &#39;__asset_subclass__&#39;], inplace=True)

    return df</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="brownbear.fetch.add_fundamental_columns"><code class="name flex">
<span>def <span class="ident">add_fundamental_columns</span></span>(<span>inv_opts, clean=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Add fundamental data columns to inv_opts dataframe.</p>
<p>Columns added:
'Previous Close',
'Trailing PE',
'Dividend Yield',
'Market Cap'</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>inv_opts</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>Dataframe of investment options with columns for asset class,
description, and performace metrics.</dd>
<dt><strong><code>clean</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>True to remove rows that have a 'nan' as a column value
(default is True).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>inv_opts</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>Dataframe of investment options with fundamental data columns.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_fundamental_columns(inv_opts, clean=True):
    &#34;&#34;&#34;
    Add fundamental data columns to inv_opts dataframe.

    Columns added:
      &#39;Previous Close&#39;,
      &#39;Trailing PE&#39;,
      &#39;Dividend Yield&#39;,
      &#39;Market Cap&#39;

    Parameters
    ----------
    inv_opts : pd.DataFrame
        Dataframe of investment options with columns for asset class,
        description, and performace metrics.
    clean : bool, optional
        True to remove rows that have a &#39;nan&#39; as a column value
        (default is True).

    Returns
    -------
    inv_opts : pd.DataFrame
        Dataframe of investment options with fundamental data columns.
    &#34;&#34;&#34;
    filepath = bb.ROOT / &#39;tools&#39; / &#39;symbol-cache&#39; / &#39;fundamentals.csv&#39;
    df = pd.read_csv(filepath)
    df.rename(columns={
        &#39;symbol&#39;: &#39;Investment Option&#39;,
        &#39;previousClose&#39;: &#39;Previous Close&#39;,
        &#39;trailingPE&#39;: &#39;Trailing PE&#39;,
        &#39;dividendYield&#39;: &#39;Dividend Yield&#39;,
        &#39;marketCap&#39;: &#39;Market Cap&#39;
        }, inplace=True)
    inv_opts = inv_opts.merge(df, how=&#39;left&#39;)
    if clean:
        # Remove any rows that have nan for column values.
        inv_opts = inv_opts.dropna()
        inv_opts.reset_index(drop=True, inplace=True)
    return inv_opts</code></pre>
</details>
</dd>
<dt id="brownbear.fetch.fetch"><code class="name flex">
<span>def <span class="ident">fetch</span></span>(<span>investment_universe, risk_free_rate=0, annual_returns='Annual Returns', vola='Std Dev', ds_vola='Std Dev', clean=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch Investment Universe and asset classes</p>
<p>investment-options.csv format:
"Investment Option", "Description"(optimal), "Asset Class",
"Annual Returns", "Std Dev"</p>
<p>asset-classes.csv format:
"Asset Class A", "Asset Class B","Correlation"
"Description" field is optional.
It is not referenced in code.
"Annual Returns" column(s) can named anything.
Recommend "1 Yr", "3 Yr", "5 Yr", or "10 Yr".
Then
annual_returns parameter can select the column to use.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>investment_universe</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>List of investment galaxies.
These are the dirs within
universe/, for example ['dow30-galaxy', 'alabama-galaxy'].</dd>
<dt><strong><code>risk_free_rate</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Risk free rate (default is 0).</dd>
<dt><strong><code>annual_returns</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Specifies which column to use for annualized returns
(default is 'Annual Returns').</dd>
<dt><strong><code>vola</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Specifies which column to use for volatility
(default is 'Std Dev').</dd>
<dt><strong><code>ds_vola</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Specifies which column to use for downside volatility
(default is 'Std Dev').</dd>
<dt><strong><code>clean</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>True to remove rows that have a 'nan' as a column value
(default is True).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>inv_opts</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>Dataframe of investment options with columns for asset class,
description, and performace metrics.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetch(investment_universe, risk_free_rate=0, annual_returns=&#39;Annual Returns&#39;,
          vola=&#39;Std Dev&#39;, ds_vola=&#39;Std Dev&#39;, clean=True):
    &#34;&#34;&#34;
    Fetch Investment Universe and asset classes

    investment-options.csv format:
        &#34;Investment Option&#34;, &#34;Description&#34;(optimal), &#34;Asset Class&#34;,
        &#34;Annual Returns&#34;, &#34;Std Dev&#34;

    asset-classes.csv format:
        &#34;Asset Class A&#34;, &#34;Asset Class B&#34;,&#34;Correlation&#34;
        &#34;Description&#34; field is optional.  It is not referenced in code.
        &#34;Annual Returns&#34; column(s) can named anything.
            Recommend &#34;1 Yr&#34;, &#34;3 Yr&#34;, &#34;5 Yr&#34;, or &#34;10 Yr&#34;.  Then
            annual_returns parameter can select the column to use.

    Parameters
    ----------
    investment_universe : list of str
        List of investment galaxies.  These are the dirs within
        universe/, for example [&#39;dow30-galaxy&#39;, &#39;alabama-galaxy&#39;].
    risk_free_rate : float, optional
        Risk free rate (default is 0).
    annual_returns : str, optional
        Specifies which column to use for annualized returns
        (default is &#39;Annual Returns&#39;).
    vola : str, optional
        Specifies which column to use for volatility
        (default is &#39;Std Dev&#39;).
    ds_vola : str, optional
        Specifies which column to use for downside volatility
        (default is &#39;Std Dev&#39;).
    clean : bool, optional
        True to remove rows that have a &#39;nan&#39; as a column value
        (default is True).

    Returns
    -------
    inv_opts : pd.DataFrame
        Dataframe of investment options with columns for asset class,
        description, and performace metrics.
    &#34;&#34;&#34;
    # If caller specified a single filename, put it in a list.
    if not isinstance(investment_universe, list):
        investment_universe = [investment_universe]

    # Create the investment options csv file list, then read into
    # a dataframe.  There are 2 places to look for
    # investment-options.csv files: under universe/ and portfolios/.
    filepaths = []
    for galaxy in investment_universe:
        for subdir in [&#39;universe&#39;, &#39;portfolios&#39;]:
            filepath = bb.ROOT / subdir / galaxy / &#39;investment-options.csv&#39;
            if filepath.is_file():
                filepaths.append(filepath)

    inv_opts = csv_to_df(filepaths)

    # Drop duplicate Investment Option&#39;s, keep the first,
    # then reset index.
    inv_opts.drop_duplicates(subset=[&#39;Investment Option&#39;], keep=&#39;first&#39;, inplace=True)
    inv_opts.reset_index(drop=True, inplace=True)

    # Allows the use of different annualized returns,
    # e.g. 1, 3, or 5 year annaulized returns.
    if annual_returns != &#39;Annual Returns&#39;:
        inv_opts[&#39;Annual Returns&#39;] = inv_opts[annual_returns]

    # Add Sharpe Ratio column.
    inv_opts = _add_sharpe_ratio_column(inv_opts, risk_free_rate)

    # Asset class table.
    PORT.asset_class_table = csv_to_df(
        [bb.ROOT / &#39;universe&#39; / &#39;asset-class-galaxy&#39; / &#39;investment-options.csv&#39;])

    # Add Annual Returns column to asset class table.
    if annual_returns in PORT.asset_class_table.columns:
        PORT.asset_class_table[&#39;Annual Returns&#39;] = PORT.asset_class_table[annual_returns]
    else:
        PORT.asset_class_table[&#39;Annual Returns&#39;] = PORT.asset_class_table[&#39;5 Yr&#39;]

    # Add Sharpe Ratio column to asset class table.
    PORT.asset_class_table = _add_sharpe_ratio_column(PORT.asset_class_table, risk_free_rate)

    # Correlation table.
    PORT.correlation_table = csv_to_df(
        [bb.ROOT / &#39;universe&#39; / &#39;asset-class-galaxy&#39; / &#39;asset-classes.csv&#39;])

    # Convert correlation table to dict for easier faster processing.
    PORT.correlation_table = _correlation_table_to_dict()

    # Set other module variables.
    PORT.investment_universe = investment_universe.copy()
    PORT.risk_free_rate = risk_free_rate
    PORT.vola_column = vola
    PORT.ds_vola_column = ds_vola

    if clean:
        # Remove any rows that have nan for column values.
        inv_opts = inv_opts.dropna()
        inv_opts.reset_index(drop=True, inplace=True)

    return inv_opts</code></pre>
</details>
</dd>
<dt id="brownbear.fetch.rank"><code class="name flex">
<span>def <span class="ident">rank</span></span>(<span>inv_opts, rank_by, group_by=None, num_per_group=None, ascending=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Rank investment options.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>inv_opts</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>Dataframe of investment options with columns for asset class,
description, and performace metrics.</dd>
<dt><strong><code>rank_by</code></strong> :&ensp;<code>str</code></dt>
<dd>The performance or fundamental metric used to sort the
investment options.</dd>
<dt><strong><code>group_by</code></strong> :&ensp;<code>str</code>, optional <code>{None, 'Asset Class', 'Asset Subclass'}</code></dt>
<dd>How to group investment options (default is None, which imples
no grouping)</dd>
<dt><strong><code>num_per_group</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The number of investment options for each group
(default is None, which imples 5 if group_by is specified,
otherwise 1000).</dd>
<dt><strong><code>ascending</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>True to sort in ascending order (default is False, which imples
sorting in descending order).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>Dataframe of investment options with ranking.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rank(inv_opts, rank_by, group_by=None, num_per_group=None, ascending=False):
    &#34;&#34;&#34;
    Rank investment options.

    Parameters
    ----------
    inv_opts : pd.DataFrame
        Dataframe of investment options with columns for asset class,
        description, and performace metrics.
    rank_by : str
        The performance or fundamental metric used to sort the
        investment options.
    group_by : str, optional {None, &#39;Asset Class&#39;, &#39;Asset Subclass&#39;}
        How to group investment options (default is None, which imples
        no grouping)
    num_per_group : int, optional
        The number of investment options for each group
        (default is None, which imples 5 if group_by is specified, 
         otherwise 1000).
    ascending : bool, optional
        True to sort in ascending order (default is False, which imples
        sorting in descending order).

    Returns
    -------
    df : pd.DataFrame
        Dataframe of investment options with ranking.
    &#34;&#34;&#34;
    group_by_choices = (None, &#39;Asset Class&#39;, &#39;Asset Subclass&#39;)
    assert group_by in group_by_choices, &#34;Invalid group_by f&#39;{group_by}&#39;&#34;

    df = inv_opts.copy()

    # Temporarily add __asset_class__ and  __asset_subclass__ for
    # convenience; drop it later.S
    df[&#39;__asset_subclass__&#39;] = df[&#39;Asset Class&#39;]

    def _add_asset_class(row):
        # Extract the class_name from &#39;__asset_subclass__&#39; column.
        class_name = row[&#39;__asset_subclass__&#39;]
        class_name = class_name.split(&#39;:&#39;)[0]
        return class_name

    # Add &#39;__asset_class__&#39; column.
    df[&#39;__asset_class__&#39;] = df.apply(_add_asset_class, axis=1)

    # Sort.
    if group_by is None:
        if num_per_group is None:
            num_per_group = 10000
        df = df.sort_values(rank_by, ascending=ascending) \
                            .head(num_per_group)
    elif group_by == &#39;Asset Class&#39;:
        if num_per_group is None:
            num_per_group = 5
        df = df.sort_values([&#39;__asset_class__&#39;, rank_by], ascending=ascending) \
                            .groupby(&#39;__asset_class__&#39;).head(num_per_group)
    elif group_by == &#39;Asset Subclass&#39;:
        if num_per_group is None:
            num_per_group = 5
        df = df.sort_values([&#39;__asset_subclass__&#39;, rank_by], ascending=ascending) \
                            .groupby(&#39;__asset_subclass__&#39;).head(num_per_group)
    else:
        raise Exception(f&#34;Error: Invalid value for groupby: &#39;{group_by}&#39;&#34;)

    # Drop temporary column.
    df.drop(columns=[&#39;__asset_class__&#39;, &#39;__asset_subclass__&#39;], inplace=True)

    return df</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="brownbear" href="index.html">brownbear</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="brownbear.fetch.add_fundamental_columns" href="#brownbear.fetch.add_fundamental_columns">add_fundamental_columns</a></code></li>
<li><code><a title="brownbear.fetch.fetch" href="#brownbear.fetch.fetch">fetch</a></code></li>
<li><code><a title="brownbear.fetch.rank" href="#brownbear.fetch.rank">rank</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>