<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>brownbear.weight API documentation</title>
<meta name="description" content="Portfolio analysis and optimization." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>brownbear.weight</code></h1>
</header>
<section id="section-intro">
<p>Portfolio analysis and optimization.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Portfolio analysis and optimization.
&#34;&#34;&#34;

import math

import numpy

import brownbear as bb
from brownbear.portfolio import (
    PORT,
    get_metric_lists,
    sharpe_ratio
)
from brownbear.utility import (
    dotdict
)


def _calc_weights(df, asset_dict, weight_by):
    &#34;&#34;&#34;
    Calculate weights for assets in asset_dict using weight_by method.
    &#34;&#34;&#34;
    weight_by_choices = (&#39;Equal&#39;, &#39;Sharpe Ratio&#39;, &#39;Annual Returns&#39;,
                         &#39;Std Dev&#39;, &#39;Vola&#39;, &#39;DS Vola&#39;)
    assert weight_by in weight_by_choices, f&#34;Invalid weight_by &#39;{weight_by}&#39;&#34;

    ml = get_metric_lists(df, asset_dict)
    bb.DBG(f&#39;asset_dict = {asset_dict}&#39;)
    bb.DBG(f&#39;asset_dict_ml = {ml}&#39;)

    if weight_by == &#39;Equal&#39;:
        n = len(asset_dict)
        weights = [1/n] * n
        asset_dict.update(zip(asset_dict, weights))

    elif weight_by in (&#39;Sharpe Ratio&#39;, &#39;Annual Returns&#39;):
        # If there are any negative returns, apply unity-based normalization.
        # if a return is negative, then sharpe_ratio will also be negative.
        numpy.seterr(&#39;raise&#39;)
        xmin = min(ml.annual_returns)
        if xmin &lt; 0:
            a = 1; b = 10
            if len(ml.annual_returns) == 1:
                ml.annual_returns[0] = ml.sharpe_ratios[0] = a
            else:
                # Z = a + (x − xmin)*(b − a) (xmax − xmin)
                xmax = max(ml.annual_returns)
                z = [a + (x-xmin)*(b-a)/(xmax-xmin) for x in ml.annual_returns]
                ml.annual_returns = z
                # Recalculate sharpe_ratios besed on normalized annual_returns.
                ml.sharpe_ratios = [sharpe_ratio(annual_ret, std_dev, PORT.risk_free_rate)
                    for annual_ret, std_dev in zip(ml.annual_returns, ml.std_devs)]

        if weight_by == &#39;Sharpe Ratio&#39;:
            metric = ml.sharpe_ratios
        else:
            metric = ml.annual_returns

        metric_sum = sum(metric)
        if not math.isclose(metric_sum, 0):
            weights = [m/metric_sum for m in metric]
        else:
            print(&#39;ZeroMetricWarning: All investment options within this group&#39;
                  &#39; have zero {} metric.  Defaulting to Equal Weighting for {}&#39;
                  .format(weight_by, asset_dict))
            n = len(asset_dict)
            weights = [1/n] * n
        asset_dict.update(zip(asset_dict, weights))

    elif weight_by in (&#39;Std Dev&#39;, &#39;Vola&#39;, &#39;DS Vola&#39;):
        if weight_by == &#39;Std Dev&#39;:  metric = ml.std_devs
        elif weight_by == &#39;Vola&#39;:   metric = ml.volas
        else:                       metric = ml.ds_volas
        inverse_metric = [1/0.001 if math.isclose(m, 0) else 1/m \
                          for m in metric]
        inverse_metric_sum = sum(inverse_metric)
        weights = [m/inverse_metric_sum for m in inverse_metric]
        asset_dict.update(zip(asset_dict, weights))

    else:
        raise Exception(f&#39;Error: Invalid weight_by {weight_by}&#39;)


def _get_cmpt_weights(df, d, user_weights, user_weight_by):
    &#34;&#34;&#34;
    Calculate the weights not specified by user.  We need to compute
    them.
    &#34;&#34;&#34;
    w = user_weights.copy()
    d = {k : 0 for k in set(d) - set(user_weights)}
    if (d):
        _calc_weights(df, d, user_weight_by)
        multi = 1 - sum(user_weights.values())
        if multi &lt; 0: multi = 0
        for key in d: d[key] *= multi
        w.update(d)
    return w


def _calc_portfolio_option_weights(portfolio_option, ml, cmpt, user):
    &#34;&#34;&#34;
    Calculate portfolio option weights using asset class,
    asset subclass, and inv_opt weights
    &#34;&#34;&#34;
    for i, inv_opt in enumerate(ml.inv_opts):
        asset_class = ml.asset_classes[i].split(&#39;:&#39;)[0]
        asset_subclass = ml.asset_classes[i]
        asset_class_weight = 1 if user.asset_class_weight_by is None \
            else cmpt.asset_class_weights[asset_class]
        asset_subclass_weight = 1 if user.asset_subclass_weight_by is None \
            else cmpt.asset_subclass_weights[asset_subclass]
        weight = (asset_class_weight *
                  asset_subclass_weight *
                  cmpt.inv_opt_weights[inv_opt])
        portfolio_option[inv_opt] = weight


def check_allocation(weights, asset_class_name):
    &#34;&#34;&#34;
    Make sure total adds to 100.
    &#34;&#34;&#34;
    s = sum(weights.values())
    if not math.isclose(s, 1, rel_tol=1e-09, abs_tol=0.0):
        raise Exception(f&#34;Error: {asset_class_name} allocation of &#39;{s}&#39; is not 100%!!!&#34;)


def assign_weights(df, ml, portfolio_option, weight_by):

    &#34;&#34;&#34;
    Specify the weighting scheme.  It will replace the weights specified
    in the portfolio.  You can also fix the weights on some
    Investent Options, Asset Classes, and Asset Subclasses while the
    others are automatically calculated.

    &#39;Equal&#39; - will use equal weights.

    &#39;Sharpe Ratio&#39; - will use proportionally weighted allocations
    based on the percent of an investment option&#39;s sharpe ratio to
    the sum of all the sharpe ratios in the portfolio.

    &#39;Std Dev&#39; - will use standard deviation adjusted weights.

    &#39;Annual Returns&#39; - will use return adjusted weights.

    &#39;Vola&#39; - will use volatility adjusted weights.

    &#39;DS Vola&#39; - will use downside volatility adjusted weights.

    None:   &#39;Investment Option&#39; means use use specified weights.
            &#39;Asset Class&#39; means do not group by Asset Class.
            &#39;Asset Subclass means do not group by Asset Subclass.
    &#34;&#34;&#34;

    # `weight_by` user specified portfolio weights #####################
    if weight_by is None:
        return

    # Unpack `weight_by` dictionary.
    asset_class_weight_by = asset_subclass_weight_by = inv_opt_weight_by = None

    asset_class_weights     = weight_by.get(&#39;Asset Class&#39;)
    asset_subclass_weights  = weight_by.get(&#39;Asset Subclass&#39;)
    inv_opt_weights         = weight_by.get(&#39;Investment Option&#39;)

    if asset_class_weights:
        asset_class_weight_by = asset_class_weights.pop(&#39;weight_by&#39;, None)
    if asset_subclass_weights:
        asset_subclass_weight_by = asset_subclass_weights.pop(&#39;weight_by&#39;, None)
    if inv_opt_weights:
        inv_opt_weight_by = inv_opt_weights.pop(&#39;weight_by&#39;, None)

    # `user` dict is the user_specified weights.
    # `cpmt` is the computed weights.
    user = dotdict()
    cmpt = dotdict()

    # `user` initialization.
    user.asset_class_weights = asset_class_weights
    user.asset_subclass_weights = asset_subclass_weights
    user.inv_opt_weights = inv_opt_weights
    user.asset_class_weight_by = asset_class_weight_by
    user.asset_subclass_weight_by = asset_subclass_weight_by
    user.inv_opt_weight_by = inv_opt_weight_by

    # `cmpt` initialization.
    cmpt.asset_class_weights = {key.split(&#39;:&#39;)[0] : 0 for key in ml.asset_classes}
    cmpt.asset_subclass_weights = {key : 0 for key in ml.asset_classes}
    cmpt.inv_opt_weights = {key : 0 for key in ml.inv_opts}

    # Handle invalid weight_by combinations.
    msg = ( &#39;WeightByWarning: A value is set on Asset Class weight_by or&#39;
            &#39; Asset Subclass weight_by, even though Investment Option weight_by&#39;
            &#39; is None.  These setting are disabled when Investment Option&#39;
            &#39; weight_by is None&#39;)

    if (user.inv_opt_weight_by is None and
       (user.asset_class_weight_by or user.asset_subclass_weight_by)):
        print(msg)
        return

    # `weight_by` user specified portfolio weights.
    if user.inv_opt_weight_by is None:
        return

    # `weight_by` inv_opts only.
    if (user.inv_opt_weight_by and 
        user.asset_class_weight_by is None and
        user.asset_subclass_weight_by is None):

        bb.DBG(user.inv_opt_weights, user.inv_opt_weight_by)

        # Use the weights in the dictionary, then the `weight_by` method
        # for the remaining `inv_opts`.
        assert(set(user.inv_opt_weights).issubset(set(cmpt.inv_opt_weights))), \
               &#34;Invalid Investment Option in weight_by!&#34;
        d = cmpt.inv_opt_weights
        w = _get_cmpt_weights(df, d, user.inv_opt_weights, user.inv_opt_weight_by)
        check_allocation(w, &#39;Investment Option&#39;)
        cmpt.inv_opt_weights.update(w)
        bb.DBG(&#39;cmpt.inv_opt_weights&#39;, cmpt.inv_opt_weights)

        _calc_portfolio_option_weights(portfolio_option, ml, cmpt, user)
        bb.DBG(&#39;portfolio_option&#39;, portfolio_option)
        return

    # `weight_by` all.
    if (user.inv_opt_weight_by and
        user.asset_class_weight_by and
        user.asset_subclass_weight_by):

        bb.DBG(user.inv_opt_weights, user.inv_opt_weight_by)
        bb.DBG(user.asset_class_weights, user.asset_class_weight_by)
        bb.DBG(user.asset_subclass_weights, user.asset_subclass_weight_by)

        # Compute asset class weights within portfolio.
        assert(set(user.asset_class_weights).issubset(set(cmpt.asset_class_weights))), \
               &#34;Invalid Asset Class in weight_by!&#34;
        d = cmpt.asset_class_weights
        w = _get_cmpt_weights(PORT.asset_class_table, d, user.asset_class_weights,
                              user.asset_class_weight_by)
        check_allocation(w, &#39;Asset Class&#39;)
        cmpt.asset_class_weights.update(w)
        bb.DBG(&#39;cmpt.asset_class_weights&#39;, cmpt.asset_class_weights)

         # Compute asset subclass weights within each asset class.
        assert(set(user.asset_subclass_weights).issubset(set(cmpt.asset_subclass_weights))), \
               &#34;Invalid Asset Sublass in weight_by!&#34;
        for asset_class in cmpt.asset_class_weights.copy():
            # d: get asset subclasses for this asset_class.
            d = {k: v for k, v in cmpt.asset_subclass_weights.items() if k.startswith(asset_class)}
            # i: get the intersection of d and user specified asset_subclasses.
            i = d.keys() &amp; user.asset_subclass_weights.keys()
            user._asset_subclass_weights = {k: user.asset_subclass_weights[k] for k in i}
            w = _get_cmpt_weights(PORT.asset_class_table, d, user._asset_subclass_weights,
                                  user.asset_subclass_weight_by)
            check_allocation(w, &#39;Asset Sublass&#39;)
            cmpt.asset_subclass_weights.update(w)
        bb.DBG(&#39;cmpt.asset_subclass_weights&#39;, cmpt.asset_subclass_weights)

        # Compute investment option weights within each asset subclass.
        assert(set(user.inv_opt_weights).issubset(set(cmpt.inv_opt_weights))), \
               &#34;Invalid Investment Option in weight_by!&#34;
        for asset_subclass in cmpt.asset_subclass_weights.copy():
            # d: get investment options for this asset_subclass.
            d = {k: v for i, (k, v) in enumerate(cmpt.inv_opt_weights.items()) \
                      if ml.asset_classes[i] == asset_subclass}
            # i: get the intersection of d and user specified inv_opts.
            i = d.keys() &amp; user.inv_opt_weights.keys()
            user._inv_opt_weights = {k: user.inv_opt_weights[k] for k in i}
            w = _get_cmpt_weights(df, d, user._inv_opt_weights, user.inv_opt_weight_by)
            check_allocation(w, &#39;Investment Option&#39;)
            cmpt.inv_opt_weights.update(w)
        bb.DBG(&#39;cmpt.inv_opt_weights&#39;, cmpt.inv_opt_weights)

        _calc_portfolio_option_weights(portfolio_option, ml, cmpt, user)
        bb.DBG(&#39;portfolio_option&#39;, portfolio_option)
        return

    # `weight_by` `inv_opt`` and asset_class.
    if (user.inv_opt_weight_by and
        user.asset_class_weight_by and
        user.asset_subclass_weight_by is None):

        bb.DBG(user.inv_opt_weights, user.inv_opt_weight_by)
        bb.DBG(user.asset_class_weights, user.asset_class_weight_by)

        # Compute asset class weights within portfolio.
        assert(set(user.asset_class_weights).issubset(set(cmpt.asset_class_weights))), \
               &#34;Invalid Asset Class in weight_by!&#34;
        d = cmpt.asset_class_weights
        w = _get_cmpt_weights(PORT.asset_class_table, d, user.asset_class_weights, user.asset_class_weight_by)
        check_allocation(w, &#39;Asset Class&#39;)
        cmpt.asset_class_weights.update(w)
        bb.DBG(&#39;cmpt.asset_class_weights&#39;, cmpt.asset_class_weights)

        # Compute investment option weights within each asset class.
        assert(set(user.inv_opt_weights).issubset(set(cmpt.inv_opt_weights))), \
               &#34;Invalid Investment Option in weight_by!&#34;
        for asset_class in cmpt.asset_class_weights.copy():
            # d: get investment options for this asset_class.
            d = {k: v for i, (k, v) in enumerate(cmpt.inv_opt_weights.items()) \
                      if ml.asset_classes[i].split(&#39;:&#39;)[0] == asset_class}
            # i: get the intersection of d and user specified `inv_opts`.
            i = d.keys() &amp; user.inv_opt_weights.keys()
            user._inv_opt_weights = {k: user.inv_opt_weights[k] for k in i}
            w = _get_cmpt_weights(df, d, user._inv_opt_weights, user.inv_opt_weight_by)
            check_allocation(w, &#39;Investment Option&#39;)
            cmpt.inv_opt_weights.update(w)
        bb.DBG(&#39;cmpt.inv_opt_weights&#39;, cmpt.inv_opt_weights)

        _calc_portfolio_option_weights(portfolio_option, ml, cmpt, user)
        bb.DBG(&#39;portfolio_option&#39;, portfolio_option)
        return

    # `weight_by` `inv_opt` and asset_subclass.
    if (user.inv_opt_weight_by and
        user.asset_class_weight_by is None and
        user.asset_subclass_weight_by):

        bb.DBG(user.inv_opt_weights, user.inv_opt_weight_by)
        bb.DBG(user.asset_subclass_weights, user.asset_subclass_weight_by)

        # Compute asset subclass weights within portfolio.
        assert(set(user.asset_subclass_weights).issubset(set(cmpt.asset_subclass_weights))), \
               &#34;Invalid Asset SubClass in weight_by!&#34;
        d = cmpt.asset_subclass_weights
        w = _get_cmpt_weights(PORT.asset_class_table, d, user.asset_subclass_weights,
                              user.asset_subclass_weight_by)
        check_allocation(w, &#39;Asset SubClass&#39;)
        cmpt.asset_subclass_weights.update(w)
        bb.DBG(&#39;cmpt.asset_subclass_weights&#39;, cmpt.asset_subclass_weights)

        # Compute investment option weights within each asset subclass.
        assert(set(user.inv_opt_weights).issubset(set(cmpt.inv_opt_weights))), \
               &#34;Invalid Investment Option in weight_by!&#34;
        for asset_subclass in cmpt.asset_subclass_weights.copy():
            # d: get investment options for this asset_subclass.
            d = {k: v for i, (k, v) in enumerate(cmpt.inv_opt_weights.items()) \
                      if ml.asset_classes[i] == asset_subclass}
            # i: get the intersection of d and user specified inv_opts.
            i = d.keys() &amp; user.inv_opt_weights.keys()
            user._inv_opt_weights = {k: user.inv_opt_weights[k] for k in i}
            w = _get_cmpt_weights(df, d, user._inv_opt_weights, user.inv_opt_weight_by)
            check_allocation(w, &#39;Investment Option&#39;)
            cmpt.inv_opt_weights.update(w)
        bb.DBG(&#39;cmpt.inv_opt_weights&#39;, cmpt.inv_opt_weights)

        _calc_portfolio_option_weights(portfolio_option, ml, cmpt, user)
        bb.DBG(&#39;portfolio_option&#39;, portfolio_option)
        return</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="brownbear.weight.assign_weights"><code class="name flex">
<span>def <span class="ident">assign_weights</span></span>(<span>df, ml, portfolio_option, weight_by)</span>
</code></dt>
<dd>
<div class="desc"><p>Specify the weighting scheme.
It will replace the weights specified
in the portfolio.
You can also fix the weights on some
Investent Options, Asset Classes, and Asset Subclasses while the
others are automatically calculated.</p>
<p>'Equal' - will use equal weights.</p>
<p>'Sharpe Ratio' - will use proportionally weighted allocations
based on the percent of an investment option's sharpe ratio to
the sum of all the sharpe ratios in the portfolio.</p>
<p>'Std Dev' - will use standard deviation adjusted weights.</p>
<p>'Annual Returns' - will use return adjusted weights.</p>
<p>'Vola' - will use volatility adjusted weights.</p>
<p>'DS Vola' - will use downside volatility adjusted weights.</p>
<p>None:
'Investment Option' means use use specified weights.
'Asset Class' means do not group by Asset Class.
'Asset Subclass means do not group by Asset Subclass.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assign_weights(df, ml, portfolio_option, weight_by):

    &#34;&#34;&#34;
    Specify the weighting scheme.  It will replace the weights specified
    in the portfolio.  You can also fix the weights on some
    Investent Options, Asset Classes, and Asset Subclasses while the
    others are automatically calculated.

    &#39;Equal&#39; - will use equal weights.

    &#39;Sharpe Ratio&#39; - will use proportionally weighted allocations
    based on the percent of an investment option&#39;s sharpe ratio to
    the sum of all the sharpe ratios in the portfolio.

    &#39;Std Dev&#39; - will use standard deviation adjusted weights.

    &#39;Annual Returns&#39; - will use return adjusted weights.

    &#39;Vola&#39; - will use volatility adjusted weights.

    &#39;DS Vola&#39; - will use downside volatility adjusted weights.

    None:   &#39;Investment Option&#39; means use use specified weights.
            &#39;Asset Class&#39; means do not group by Asset Class.
            &#39;Asset Subclass means do not group by Asset Subclass.
    &#34;&#34;&#34;

    # `weight_by` user specified portfolio weights #####################
    if weight_by is None:
        return

    # Unpack `weight_by` dictionary.
    asset_class_weight_by = asset_subclass_weight_by = inv_opt_weight_by = None

    asset_class_weights     = weight_by.get(&#39;Asset Class&#39;)
    asset_subclass_weights  = weight_by.get(&#39;Asset Subclass&#39;)
    inv_opt_weights         = weight_by.get(&#39;Investment Option&#39;)

    if asset_class_weights:
        asset_class_weight_by = asset_class_weights.pop(&#39;weight_by&#39;, None)
    if asset_subclass_weights:
        asset_subclass_weight_by = asset_subclass_weights.pop(&#39;weight_by&#39;, None)
    if inv_opt_weights:
        inv_opt_weight_by = inv_opt_weights.pop(&#39;weight_by&#39;, None)

    # `user` dict is the user_specified weights.
    # `cpmt` is the computed weights.
    user = dotdict()
    cmpt = dotdict()

    # `user` initialization.
    user.asset_class_weights = asset_class_weights
    user.asset_subclass_weights = asset_subclass_weights
    user.inv_opt_weights = inv_opt_weights
    user.asset_class_weight_by = asset_class_weight_by
    user.asset_subclass_weight_by = asset_subclass_weight_by
    user.inv_opt_weight_by = inv_opt_weight_by

    # `cmpt` initialization.
    cmpt.asset_class_weights = {key.split(&#39;:&#39;)[0] : 0 for key in ml.asset_classes}
    cmpt.asset_subclass_weights = {key : 0 for key in ml.asset_classes}
    cmpt.inv_opt_weights = {key : 0 for key in ml.inv_opts}

    # Handle invalid weight_by combinations.
    msg = ( &#39;WeightByWarning: A value is set on Asset Class weight_by or&#39;
            &#39; Asset Subclass weight_by, even though Investment Option weight_by&#39;
            &#39; is None.  These setting are disabled when Investment Option&#39;
            &#39; weight_by is None&#39;)

    if (user.inv_opt_weight_by is None and
       (user.asset_class_weight_by or user.asset_subclass_weight_by)):
        print(msg)
        return

    # `weight_by` user specified portfolio weights.
    if user.inv_opt_weight_by is None:
        return

    # `weight_by` inv_opts only.
    if (user.inv_opt_weight_by and 
        user.asset_class_weight_by is None and
        user.asset_subclass_weight_by is None):

        bb.DBG(user.inv_opt_weights, user.inv_opt_weight_by)

        # Use the weights in the dictionary, then the `weight_by` method
        # for the remaining `inv_opts`.
        assert(set(user.inv_opt_weights).issubset(set(cmpt.inv_opt_weights))), \
               &#34;Invalid Investment Option in weight_by!&#34;
        d = cmpt.inv_opt_weights
        w = _get_cmpt_weights(df, d, user.inv_opt_weights, user.inv_opt_weight_by)
        check_allocation(w, &#39;Investment Option&#39;)
        cmpt.inv_opt_weights.update(w)
        bb.DBG(&#39;cmpt.inv_opt_weights&#39;, cmpt.inv_opt_weights)

        _calc_portfolio_option_weights(portfolio_option, ml, cmpt, user)
        bb.DBG(&#39;portfolio_option&#39;, portfolio_option)
        return

    # `weight_by` all.
    if (user.inv_opt_weight_by and
        user.asset_class_weight_by and
        user.asset_subclass_weight_by):

        bb.DBG(user.inv_opt_weights, user.inv_opt_weight_by)
        bb.DBG(user.asset_class_weights, user.asset_class_weight_by)
        bb.DBG(user.asset_subclass_weights, user.asset_subclass_weight_by)

        # Compute asset class weights within portfolio.
        assert(set(user.asset_class_weights).issubset(set(cmpt.asset_class_weights))), \
               &#34;Invalid Asset Class in weight_by!&#34;
        d = cmpt.asset_class_weights
        w = _get_cmpt_weights(PORT.asset_class_table, d, user.asset_class_weights,
                              user.asset_class_weight_by)
        check_allocation(w, &#39;Asset Class&#39;)
        cmpt.asset_class_weights.update(w)
        bb.DBG(&#39;cmpt.asset_class_weights&#39;, cmpt.asset_class_weights)

         # Compute asset subclass weights within each asset class.
        assert(set(user.asset_subclass_weights).issubset(set(cmpt.asset_subclass_weights))), \
               &#34;Invalid Asset Sublass in weight_by!&#34;
        for asset_class in cmpt.asset_class_weights.copy():
            # d: get asset subclasses for this asset_class.
            d = {k: v for k, v in cmpt.asset_subclass_weights.items() if k.startswith(asset_class)}
            # i: get the intersection of d and user specified asset_subclasses.
            i = d.keys() &amp; user.asset_subclass_weights.keys()
            user._asset_subclass_weights = {k: user.asset_subclass_weights[k] for k in i}
            w = _get_cmpt_weights(PORT.asset_class_table, d, user._asset_subclass_weights,
                                  user.asset_subclass_weight_by)
            check_allocation(w, &#39;Asset Sublass&#39;)
            cmpt.asset_subclass_weights.update(w)
        bb.DBG(&#39;cmpt.asset_subclass_weights&#39;, cmpt.asset_subclass_weights)

        # Compute investment option weights within each asset subclass.
        assert(set(user.inv_opt_weights).issubset(set(cmpt.inv_opt_weights))), \
               &#34;Invalid Investment Option in weight_by!&#34;
        for asset_subclass in cmpt.asset_subclass_weights.copy():
            # d: get investment options for this asset_subclass.
            d = {k: v for i, (k, v) in enumerate(cmpt.inv_opt_weights.items()) \
                      if ml.asset_classes[i] == asset_subclass}
            # i: get the intersection of d and user specified inv_opts.
            i = d.keys() &amp; user.inv_opt_weights.keys()
            user._inv_opt_weights = {k: user.inv_opt_weights[k] for k in i}
            w = _get_cmpt_weights(df, d, user._inv_opt_weights, user.inv_opt_weight_by)
            check_allocation(w, &#39;Investment Option&#39;)
            cmpt.inv_opt_weights.update(w)
        bb.DBG(&#39;cmpt.inv_opt_weights&#39;, cmpt.inv_opt_weights)

        _calc_portfolio_option_weights(portfolio_option, ml, cmpt, user)
        bb.DBG(&#39;portfolio_option&#39;, portfolio_option)
        return

    # `weight_by` `inv_opt`` and asset_class.
    if (user.inv_opt_weight_by and
        user.asset_class_weight_by and
        user.asset_subclass_weight_by is None):

        bb.DBG(user.inv_opt_weights, user.inv_opt_weight_by)
        bb.DBG(user.asset_class_weights, user.asset_class_weight_by)

        # Compute asset class weights within portfolio.
        assert(set(user.asset_class_weights).issubset(set(cmpt.asset_class_weights))), \
               &#34;Invalid Asset Class in weight_by!&#34;
        d = cmpt.asset_class_weights
        w = _get_cmpt_weights(PORT.asset_class_table, d, user.asset_class_weights, user.asset_class_weight_by)
        check_allocation(w, &#39;Asset Class&#39;)
        cmpt.asset_class_weights.update(w)
        bb.DBG(&#39;cmpt.asset_class_weights&#39;, cmpt.asset_class_weights)

        # Compute investment option weights within each asset class.
        assert(set(user.inv_opt_weights).issubset(set(cmpt.inv_opt_weights))), \
               &#34;Invalid Investment Option in weight_by!&#34;
        for asset_class in cmpt.asset_class_weights.copy():
            # d: get investment options for this asset_class.
            d = {k: v for i, (k, v) in enumerate(cmpt.inv_opt_weights.items()) \
                      if ml.asset_classes[i].split(&#39;:&#39;)[0] == asset_class}
            # i: get the intersection of d and user specified `inv_opts`.
            i = d.keys() &amp; user.inv_opt_weights.keys()
            user._inv_opt_weights = {k: user.inv_opt_weights[k] for k in i}
            w = _get_cmpt_weights(df, d, user._inv_opt_weights, user.inv_opt_weight_by)
            check_allocation(w, &#39;Investment Option&#39;)
            cmpt.inv_opt_weights.update(w)
        bb.DBG(&#39;cmpt.inv_opt_weights&#39;, cmpt.inv_opt_weights)

        _calc_portfolio_option_weights(portfolio_option, ml, cmpt, user)
        bb.DBG(&#39;portfolio_option&#39;, portfolio_option)
        return

    # `weight_by` `inv_opt` and asset_subclass.
    if (user.inv_opt_weight_by and
        user.asset_class_weight_by is None and
        user.asset_subclass_weight_by):

        bb.DBG(user.inv_opt_weights, user.inv_opt_weight_by)
        bb.DBG(user.asset_subclass_weights, user.asset_subclass_weight_by)

        # Compute asset subclass weights within portfolio.
        assert(set(user.asset_subclass_weights).issubset(set(cmpt.asset_subclass_weights))), \
               &#34;Invalid Asset SubClass in weight_by!&#34;
        d = cmpt.asset_subclass_weights
        w = _get_cmpt_weights(PORT.asset_class_table, d, user.asset_subclass_weights,
                              user.asset_subclass_weight_by)
        check_allocation(w, &#39;Asset SubClass&#39;)
        cmpt.asset_subclass_weights.update(w)
        bb.DBG(&#39;cmpt.asset_subclass_weights&#39;, cmpt.asset_subclass_weights)

        # Compute investment option weights within each asset subclass.
        assert(set(user.inv_opt_weights).issubset(set(cmpt.inv_opt_weights))), \
               &#34;Invalid Investment Option in weight_by!&#34;
        for asset_subclass in cmpt.asset_subclass_weights.copy():
            # d: get investment options for this asset_subclass.
            d = {k: v for i, (k, v) in enumerate(cmpt.inv_opt_weights.items()) \
                      if ml.asset_classes[i] == asset_subclass}
            # i: get the intersection of d and user specified inv_opts.
            i = d.keys() &amp; user.inv_opt_weights.keys()
            user._inv_opt_weights = {k: user.inv_opt_weights[k] for k in i}
            w = _get_cmpt_weights(df, d, user._inv_opt_weights, user.inv_opt_weight_by)
            check_allocation(w, &#39;Investment Option&#39;)
            cmpt.inv_opt_weights.update(w)
        bb.DBG(&#39;cmpt.inv_opt_weights&#39;, cmpt.inv_opt_weights)

        _calc_portfolio_option_weights(portfolio_option, ml, cmpt, user)
        bb.DBG(&#39;portfolio_option&#39;, portfolio_option)
        return</code></pre>
</details>
</dd>
<dt id="brownbear.weight.check_allocation"><code class="name flex">
<span>def <span class="ident">check_allocation</span></span>(<span>weights, asset_class_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Make sure total adds to 100.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_allocation(weights, asset_class_name):
    &#34;&#34;&#34;
    Make sure total adds to 100.
    &#34;&#34;&#34;
    s = sum(weights.values())
    if not math.isclose(s, 1, rel_tol=1e-09, abs_tol=0.0):
        raise Exception(f&#34;Error: {asset_class_name} allocation of &#39;{s}&#39; is not 100%!!!&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="brownbear" href="index.html">brownbear</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="brownbear.weight.assign_weights" href="#brownbear.weight.assign_weights">assign_weights</a></code></li>
<li><code><a title="brownbear.weight.check_allocation" href="#brownbear.weight.check_allocation">check_allocation</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>